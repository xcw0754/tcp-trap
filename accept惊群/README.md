# accept惊群

惊群(Thundering Herd)是指一个事件唤醒了所有等待的对象，但是只有极少量的对象有必要被唤醒，其他都是多余的。

Linux平台下的网络编程很常见的accept，在旧版本中(据说2.6之前)accept是有惊群现象的，比如在一个进程中执行socket、bind和listen，然后fork出多个进程，在各个进程中阻塞式accept已在listen的句柄。当有一个连接请求来临时，所有因调用accept而阻塞的进程都会被唤醒。这是不必要的，因为最终只需要一个进程来处理这个请求就够了。惊群现象的影响就是会浪费资源，比如多个不必要的进程竞争CPU。

不过，如今新版本的accept已经没有惊群现象了，我做了个实验，发现每个进程都是轮着接收请求，比如进程A、B、C分别accept同个socket句柄，他们接收请求的顺序是A、B、C、A、B...。这个惊群问题内核帮忙解决了，但是通常我们不会用阻塞的accept，而是用select、poll和epoll，他们还是存在惊群现象，当请求来临时，每个调用epoll监听同个socket句柄的进程都会被唤醒(但是只有一个进程调用accept成功，其他的得到EAGAIN)，这是不必要的。除非只有一个进程在epoll，否则，惊群现象仍旧存在。

有人说加互斥锁行不行?看加什么锁，阻塞类型的锁肯定不能避免惊群现象，道理跟accept阻塞一样。Nginx中worker进程可能有多个，它解决惊群现象的方法是只让一个worker进程将listenfd加入到epoll中，其他的只处理当前的连接。用到的是跨进程的非阻塞互斥锁。


讨论点题外话，以前为了多个进程监听同一个socket句柄，都是先listen后fork接accept，自从有了SO_REUSEPORT之后就可以单独在一个进程里执行全套操作了，先forkt，再socket、bind、listen、accept。还有，单个服务器进程如果正在处理某个socket连接，然后进程意外终止，如果没用设置SO_REUSEPORT的话，是没法立即重新bind成功的，提示地址绑定失败。

再讨论点题外话，除了SO_REUSEPORT之外，SO_REUSEADDR也很常见。SO_REUSEADDR是用于相同的地址端口对的绑定，假如没有设置SO_REUSEADDR选项，那么0.0.0.0:1080和192.168.189.1:1080是没法同时绑定成功的，因为0.0.0.0包括了192.168.189.1。但是设置了SO_REUSEADDR后就不一样了，它们可以同时绑定成功，只是127.0.0.1:1080和127.0.0.1:1080无法被不同进程同时绑定成功，同理192.168.189.1:1080和192.168.189.1:1080也一样。

